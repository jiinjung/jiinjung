<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Internal Structure</title>
    
    <style>
    *
    {
        margin: 0;
        padding: 0;
    }

    html,
    body
    {
        overflow: hidden;
    }

    .webgl
    {
        position: fixed;
        top: 0;
        left: 0;
        outline: none;
        cursor: default;
    }
    </style>


</head>
<body>
       <canvas class="webgl"></canvas>
</body>


<script type="module">
    import './style.css'
    import * as THREE from 'three'
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
    import * as dat from 'lil-gui'
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


			const params = {
				clipIntersection: true,
				planeConstant: 0,
				showHelpers: false
			};

			const clipPlanes = [
				new THREE.Plane( new THREE.Vector3( 1, 0, 0 ), 0 ),
				new THREE.Plane( new THREE.Vector3( 0, - 1, 0 ), 0 ),
				new THREE.Plane( new THREE.Vector3( 0, 0, - 1 ), 0 )
			];

            // Debug
            const debugObject = {}
            const gui = new dat.GUI({
                width: 300
            })


            // Canvas
            const canvas = document.querySelector('canvas.webgl')

            // Scene
            const scene = new THREE.Scene()

            /** 
             * camera
             */
            let camera;
            camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
            camera.position.set( - 1.5, 2.5, 3.0 );

            /**
             * Sizes
             */
            const sizes = {
                width: window.innerWidth,
                height: window.innerHeight
            }

            window.addEventListener('resize', () =>
            {
                // Update sizes
                sizes.width = window.innerWidth
                sizes.height = window.innerHeight

                // Update camera
                camera.aspect = sizes.width / sizes.height
                camera.updateProjectionMatrix()

                // Update renderer
                renderer.setSize(sizes.width, sizes.height)
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
            })


            /** 
             * renderer
             */
            const renderer = new THREE.WebGLRenderer( {
                canvas: canvas,
                antialias: true } );
            renderer.setPixelRatio( window.devicePixelRatio );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.localClippingEnabled = true;
            document.body.appendChild( renderer.domElement );
            renderer.render( scene, camera )

    

            // Background 
            debugObject.backgroundColor = "#dfe8ec"
            renderer.setClearColor(debugObject.backgroundColor)
            gui
            .addColor(debugObject, 'backgroundColor')
            .onChange(() =>
            {
                renderer.setClearColor(debugObject.backgroundColor)
            })
            .name('background color')


            gui.add( params, 'clipIntersection' ).name( 'clip intersection' ).onChange( function ( value ) {
                const children = group.children;
                for ( let i = 0; i < children.length; i ++ ) {
                    children[ i ].material.clipIntersection = value;
                }
                render();
            } );

            gui.add( params, 'planeConstant', - 1, 1 ).step( 0.01 ).name( 'plane constant' ).onChange( function ( value ) {
            for ( let j = 0; j < clipPlanes.length; j ++ ) {
                clipPlanes[ j ].constant = value;
            }
            render();
            } );

            gui.add( params, 'showHelpers' ).name( 'show helpers' ).onChange( function ( value ) {
            helpers.visible = value;
            render();
            } );


            /** 
             * controls
             */
            const controls = new OrbitControls( camera, canvas );
            controls.minDistance = 1;
            controls.maxDistance = 10;
            controls.enablePan = false;

            /** 
             * light
             */
            const light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1.5 );
            light.position.set( - 1.25, 1, 1.25 );
            scene.add( light );

            /**
             * group
             */
            const group = new THREE.Group();
            for ( let i = 1; i <= 30; i += 2 ) {

                const geometry = new THREE.SphereGeometry( i / 30, 48, 24 );

                const material = new THREE.MeshLambertMaterial( {

                    color: new THREE.Color().setHSL( Math.random(), 0.5, 0.5 ),
                    side: THREE.DoubleSide,
                    clippingPlanes: clipPlanes,
                    clipIntersection: params.clipIntersection

                } );

                group.add( new THREE.Mesh( geometry, material ) );

            }
            // scene.add( group );


            /**
             * Earth Group
             */
            const earthGroup = new THREE.Group();

            const earthInternal = [6371, 6371-100, 6371-2885, 6371-5155, 6371-6371]
            // red, yellow, blue, green, white
            const earthColor = [0, 0.1, 0.2, 0.3, 0.4]

            for ( let i = 0; i < earthInternal.length; i++ ) {

                const geometry = new THREE.SphereGeometry( earthInternal[i] / 6371 , 64, 24 );

                const material = new THREE.MeshLambertMaterial( {

                    color: new THREE.Color().setHSL( earthColor[i], 0.5, 0.5 ),
                    side: THREE.DoubleSide,
                    clippingPlanes: clipPlanes,
                    clipIntersection: params.clipIntersection

                } );

                earthGroup.add( new THREE.Mesh( geometry, material ) );

            }

            scene.add( earthGroup );



        function render() {

            renderer.render( scene, camera );

        }

        /**
         * Animate
         */
        const clock = new THREE.Clock()
        let previousTime = 0

        const tick = () =>
        {
            const elapsedTime = clock.getElapsedTime()
            const deltaTime = elapsedTime - previousTime
            previousTime = elapsedTime

            // directionalLight.position.z = Math.cos(elapsedTime)

            // Update controls
            controls.update()

            // Render
            renderer.render(scene, camera)

            // Call tick again on the next frame
            window.requestAnimationFrame(tick)
        }

        tick()




</script>
</html>