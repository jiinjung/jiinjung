<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> Spherical Harmonics </title>

    <style>
        *
    {
        margin: 0;
        padding: 0;
    }

    html,
    body
    {
        overflow: hidden;
    }

    .webgl
    {
        position: fixed;
        top: 0;
        left: 0;
        outline: none;
        cursor: default;
    }


    @font-face {
            font-family: nasalization;
            src: url(../static/fonts/nasalization/nasalization-rg.otf);
    }

    #credits {
        position: absolute;
        bottom: 10px;
        right: 10px;
        font-size: 20px;
        font-weight: bold;
        font-family: nasalization;
        color: #fff;
        z-index: 99;
    }

    .link {
        color: rgb(225, 148, 255);
        text-decoration: none;
        font-weight: bold;
        font-size: 20px;
        font-family: nasalization;

    }

    .link:hover {
        color: rgb(115, 213, 255);
        text-decoration: none;
        font-weight: bold;
        font-size: 20px;
        font-family: nasalization;
        cursor: pointer;
    }


    </style>
</head>
<body>

    <div id="credits"> <p style="font-size: small;">Magnetic Field Inclination for Dipole, Quadrupole, and Octupole calculations by zonal spherical harmonics.Inspired by
        <a class='link' href="https://www.nature.com/articles/s41550-021-01469-y" target="_blank" style="font-size: small;"> [Nichols et al., 2021] </a></p>
    </div>


    <canvas class="webgl"></canvas>
    <script type="module">
    import './style.css'
    import * as THREE from 'three'
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js'
    import * as dat from 'lil-gui'
    import { GUI } from 'three/addons/libs/lil-gui.module.min.js';


        
    function lonlat2cart(R, lat, lon)
    {
        let plat = lat * Math.PI / 180
        let plon = lon * Math.PI / 180
        let px = - R * Math.cos(plat) * Math.cos(plon)
        let py = R * Math.cos(plat) * Math.sin(plon)
        let pz = R * Math.sin(plat) 

        let ans = new THREE.Vector3(px, pz, py)
        return ans
    }

    function sphInclination(lat, G1, G2, G3){

        let colat = (90 - lat) * Math.PI / 180
        let r_hat = G1 * (2 * Math.cos(colat)) + G2 * (4.5 * Math.cos(colat)**2 - 1.5) + G3 * (10 * Math.cos(colat)**3 - 6 * Math.cos(colat))
        let theta_hat = G1 * (Math.sin(colat)) + G2 * (3 * Math.cos(colat) * Math.sin(colat)) + G3 * (7.5 * Math.cos(colat)**2 * Math.sin(colat) - 1.5 * Math.sin(colat))
        // if theta_hat = 0 add a small number to avoid division by zero
        if (theta_hat == 0){
            theta_hat = 0.0001
        }

    return Math.atan(r_hat/theta_hat)

    }



    function sph2cart(R, theta, phi)
    {
        let ptheta = theta * Math.PI / 180
        let pphi = phi * Math.PI / 180
        let px = R * Math.sin(ptheta) * Math.cos(pphi)
        let py = R * Math.sin(ptheta) * Math.sin(pphi)
        let pz = R * Math.cos(ptheta) 

        let ans = new THREE.Vector3(px, pz, py)
        return ans
    }

    /**
     * Base
     */
    // Debug
    const gui = new GUI()
    gui.domElement.style.width = '400px'
    const debugObject = {}
    // make text of gui font
    gui.domElement.style.fontFamily = 'nasalization'
    gui.domElement.style.fontSize = '14px'
    

    // Canvas
    const canvas = document.querySelector('canvas.webgl')

    // Scene
    const scene = new THREE.Scene()

    /** 
     * camera
     */
        let camera;
    camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 200 );
    camera.position.set( - 1.5, 2.5, 3.0 );


    /**
     * Sizes
     */
        const sizes = {
        width: window.innerWidth,
        height: window.innerHeight
    }

    window.addEventListener('resize', () =>
    {
        // Update sizes
        sizes.width = window.innerWidth
        sizes.height = window.innerHeight

        // Update camera
        camera.aspect = sizes.width / sizes.height
        camera.updateProjectionMatrix()

        // Update renderer
        renderer.setSize(sizes.width, sizes.height)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
    })


    /** 
     * renderer
     */
    const renderer = new THREE.WebGLRenderer( {
        canvas: canvas,
        antialias: true } );
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    document.body.appendChild( renderer.domElement );
    renderer.render( scene, camera )

    function render() {

    renderer.render( scene, camera );

    }

    const sphereGeometry = new THREE.SphereGeometry(1, 48, 24)
    const sphereMaterial = new THREE.MeshLambertMaterial( { 
        color: new THREE.Color().setHSL( 0.5, 0.5, 0.5 ),
        side: THREE.DoubleSide,
        wireframe: true
        } );
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial)
    scene.add(sphere)
    sphere.position.set(0, 0, 0)


    const parameters = {}
    parameters.lat = 10
    parameters.lon = 10
    parameters.scale = 0.5
    parameters.G1 = 1
    parameters.G2 = 0
    parameters.G3 = 0
    parameters.inColor = '#F53D7D'
    parameters.outColor = '#2963f5'


    let coneGeometry = null
    let coneMaterial = null
    let coneGroup = null

    const generatedirections = () =>
    {
        // Destroy old galaxy
        if(coneGroup !== null)
        {
            coneGeometry.dispose()
            coneMaterial.dispose()
            scene.remove(coneGroup)
        }

        coneGroup = new THREE.Group()

        const colorIn = new THREE.Color(parameters.inColor)
        const colorOut = new THREE.Color(parameters.outColor)

        for (let i = - 90; i < 90 ; i+= parameters.lat)
        {
            for (let j = -180; j < 180; j+= parameters.lon)
            {

                coneGeometry = new THREE.ConeGeometry(0.015, 0.2, 10)
                coneMaterial = new THREE.MeshLambertMaterial(  );

                let cone = new THREE.Mesh(coneGeometry, coneMaterial)
                let curLoc = lonlat2cart(1, i, j)
                cone.position.copy(curLoc)

                cone.scale.multiplyScalar(parameters.scale)
                cone.position.copy(curLoc)

                cone.lookAt(0, 0, 0)
                cone.rotateX(sphInclination(i, parameters.G1, parameters.G2, parameters.G3))
                coneGroup.add(cone)

                // Color
                const mixedColor = colorOut.clone()
                mixedColor.lerp(colorIn, sphInclination(i, parameters.G1, parameters.G2, parameters.G3))
                cone.material.color = mixedColor
                
            }
        }
        scene.add(coneGroup)
    }

    gui.add(parameters, 'lat').min(5).max(20).step(1).onFinishChange(generatedirections).name('Lat Resolution (Deg)')
    gui.add(parameters, 'lon').min(5).max(20).step(1).onFinishChange(generatedirections).name('Long Resolution (Deg)')
    gui.add(parameters, 'scale').min(0.1).max(1).step(0.01).onFinishChange(generatedirections).name('Scale')
    gui.add(parameters, 'G1').min(0).max(1).step(0.01).onFinishChange(generatedirections).name('G1 (Dipole)')
    gui.add(parameters, 'G2').min(0).max(1).step(0.01).onFinishChange(generatedirections).name('G2 (Quadrupole)')
    gui.add(parameters, 'G3').min(0).max(1).step(0.01).onFinishChange(generatedirections).name('G3 (Octupole)')
    gui.addColor(parameters, 'inColor').onFinishChange(generatedirections)
    gui.addColor(parameters, 'outColor').onFinishChange(generatedirections)

    generatedirections()


    // Lights
    const pointLight = new THREE.PointLight(0xffffff, 1)
    pointLight.position.x = 2
    pointLight.position.y = 3
    pointLight.position.z = 4
    scene.add(pointLight)


    //add x, y, z helper
    const axesHelper = new THREE.AxesHelper( 10 );
    scene.add( axesHelper );


    /** 
     * controls
     */
        const controls = new OrbitControls( camera, canvas );
    controls.minDistance = 3;
    controls.maxDistance = 10;
    controls.enablePan = false;

    /** 
     * light
     */
    const light = new THREE.HemisphereLight( 0xffffff, 0x080808, 1.5 );
    light.position.set( - 1.25, 1, 1.25 );
    scene.add( light );


    /**
     * Animate
     */
        const clock = new THREE.Clock()
    let previousTime = 0

    const tick = () =>
    {
        const elapsedTime = clock.getElapsedTime()
        const deltaTime = elapsedTime - previousTime
        previousTime = elapsedTime

        // Update controls
        controls.update()

        // Render
        renderer.render(scene, camera)

        // Call tick again on the next frame
        window.requestAnimationFrame(tick)

        // rotate camera
        camera.position.x = Math.cos(elapsedTime * 0.1 ) * 3 
        camera.position.z = Math.sin(elapsedTime * 0.1 ) * 3
        camera.lookAt(0, 0, 0)
        
    }

    tick()
    

    </script>

</body>
</html>